%-------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%-------------------------------------------------------------------------------
\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, 
                                                 % the default font and small 
                                                 % caps

\pagestyle{fancyplain} % Makes all pages in the document conform to the custom
                       % headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as 
             % the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 
                                 % 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2,
                               % 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 
                              % 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment 
                          % this line for an assignment with lots of text

%-------------------------------------------------------------------------------
%   TITLE SECTION
%-------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % horizontal cmd, arg = height
\newcommand{\name}{Colin Bradford} % student name
\newcommand{\hwnum}{2} % homework number
\newcommand{\classnum}{CS 325} % class num with abreviation
\newcommand{\classname}{Analysis of Algorithms} % name of class
\newcommand{\hwtitle}{\classnum: Project \hwnum}

\title{ 
    \normalfont \normalsize 
    \textsc{Oregon State University} \\ [25pt]
    \large Project Group 21
    \horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
    \huge \hwtitle \\ % The assignment title
    \horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{
    Colin Bradford
    \and
    Charles Jenkins
    \and
    Albert Le
} % Your name

\date{\normalsize\today} % Today's date or a custom date

%-------------------------------------------------------------------------------
%   DOCUMENT
%-------------------------------------------------------------------------------
\begin{document}

\maketitle % Print the title

\begin{enumerate}
    \item The dynamic programming table is filled in by determining what positions
    in the table are "next" to each other. It basically creates multiple paths 
    to different values. Two values are needed for the table: the amount of coins 
    required to get to the current change, and the previous table position 
    (which can be found if you have the coin value). Assuming that all table
    positions already visited have the minimum number of coins required to get
    to that amount of change, then we can see that if we use previous table
    positions to determine which coin will provide the minimum number of coins
    to get to the current position that all table positions will correctly have
    the minimum number of coins and provide a way to find which coins.

    \item Pseudo-code
    \begin{description}
        \item[changeslow] \hfill \\
        \begin{algorithmic}
            \Require{$A$ is the target change value, and $V$ is an array of all
                     the coin values.}
            \Function{changeslow}{$V$, $A$}
                \State $n \gets V$.size
                \State $coins \gets$ []
                \State $min_m \gets \infty$
                \If{$A == 0$}
                    \State $min_m \gets 0$
                    \Return $coins, min_m$
                \EndIf
                \For{$i \gets 0 \textrm{ to } n$}
                    \State $next_pos \gets A - V[i]$
                    \If{$next_pos \geq 0$}
                        \State $C, m \gets$ \Call{changeslow}{$V, next_pos$}
                        \If{$m + 1 < min_m$}
                            \State $min_m \gets m + 1$
                            \State $coins = C$
                            \State $C[i] += 1$
                        \EndIf
                    \EndIf
                \EndFor
                \State \Return $coins, min_m$
            \EndFunction
        \end{algorithmic}

        \item[changegreedy] \hfill \\
        \begin{algorithmic}
            \Require{$A$ is the target change value, and $V$ is an array of all
                     the coin values.}
            \Function{changegreedy}{$V$, $A$}
                \State $n \gets V$.size
                \State $coins \gets$ []
                \State $min_m \gets \infty$
                \For{$i \gets n \textrm{ to } 0$}
                    \While{$A \geq V[i]$}
                        \State $coins[i] \gets coins[i] + 1$
                        \State $min_m \gets min_m + 1$
                    \EndWhile
                \EndFor
                \Return $coins, min_m$
            \EndFunction
        \end{algorithmic}

        \item[changedp] \hfill \\
        \begin{algorithmic}
            \Require{$A$ is the target change value, and $V$ is an array of all
                     the coin values.}
            \Function{changedp}{$V$, $A$}
                \State $n \gets V$.size
                \State $C \gets$ []
                \State $T \gets$ []
                \State $vals \gets$ []
                \For{$i \gets 0 \textrm{ to } A$}
                    \For{$j \gets 0 \textrm{ to } n$}
                        \State $prev_pos \gets i - V[j]$
                        \If{$prev_pos \geq 0$}
                            \If{$T[prev_pos] + 1 < T[i]$}
                                \State $T[i] \gets T[prev_pos] + 1$
                                \State $vals[i] \gets j$
                            \EndIf
                        \EndIf
                    \EndFor
                \EndFor
                \State $j \gets A$
                \While{$j > 0$}
                    \State $i \gets vals[j]$
                    \State $C[i] \gets C[i] + 1$
                    \State $j \gets j - V[i]$
                \EndWhile
                \Return $C, T[A]$
            \EndFunction
        \end{algorithmic}
    \end{description}
    
    \item <Proof of correctness of dynamic programming approach>
    
    \item Supposing $V = [1, 5, 10, 25, 50]$, for each integer value of A in $[2010, 2015, 2020, ..., 2200]$ the number of coins required by changegreedy and changedp are plotted below: <INSERT GREEDY PLOT> <INSERT DP PLOT> <NEED SLOW???> <COMPARE APPROACHES>
    
    \item Supposing $V_1 = [1, 2, 6, 12, 24, 48, 60]$ and $V_2 = [1, 6, 13, 37, 150]$, for each integer value of A in $[2000, 2001, 2002, ..., 2200]$ the number of coins required by changegreedy and changedp are plotted below: <INSERT V1 GREEDY PLOT> <INSERT V1 DP PLOT> <NEED V1 SLOW???> <INSERT V2 GREEDY PLOT> <INSERT V2 DP PLOT> <NEED V2 SLOW???> <COMPARE APPROACHES>
    
    \item Supposing $V = [1, 2, 4, 6, 8, 10, 12, ..., 30]$ for each integer value of A in $[2000, 2001, 2002, ..., 2200]$ the number of coins required by changegreedy and changedp are plotted below: <INSERT GREEDY PLOT> <INSERT DP PLOT> <NEED SLOW???>
    
    \item <INSERT TREND LINE EQUATIONS AND FIND RUNTIME> <INSERT RUNNING TIME GRAPH> <COMPARE RUNNING TIMES>
    
    \item <PLOT RUNNING TIMES AS FUNCTION OF NUMBER OF DENOMINATIONS> <DOES SIZE OF N INFLUENCE RUNNING TIMES?>
    
    \item
    Given that the set of coins $V = [p^0, p^1, p^2, \ldots, p^n]$, then we know
    that the greedy algortihm will always return a correct result. We can see
    this if we consider that any $A$ can be written as 
    \[ A = x_0p^0 + x_1p^1 + x_2p^2 + \ldots + x_np^n \]
    where $x_k \in \mathbb{Z}$ and $0 \leq x_k \leq p - 1$
    
    We will not prove that this claim is true as it is used in practice: 
    computers store positive integers in bytes where each bit represents $p^k$ 
    and its value represents $x_k$ ($p = 2$ in this case). Thus in this 
    scenario, it would be best to use the greedy algorithm as it will always 
    return the correct result, and is faster than the dynamic programming 
    algorithm. 

    The greedy algorithm will have a run time of roughly $\Theta(n)$ where $n$
    is the number of coins. While the dp algorithm will have a run time of
    roughly $\Theta(An)$.
\end{enumerate}

\end{document}
%-------------------------------------------------------------------------------


